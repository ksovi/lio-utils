// this is a GO Lang implementation of the python script to check cachefs based on ars.cache file
//
package main
import (
    "bufio"
    "fmt"
    "io"
    "strings"
    "syscall"
    "strconv"
    //"io/ioutil"
    "os"
    "flag"
)

func check(e error) {
    if e != nil {
        fmt.Println(e)
        os.Exit(12)
    }
}

func RunProgram(arsfile , status string) {
    // define a slice here that will contain possible datasets that aren't available
    broken_datasets := make([] string, 0)

    var totalSpace, totalAvailable float64
    totalSpace = 0
    totalAvailable = 0

    fp, err := os.Open(arsfile)
    check(err)
    defer fp.Close()
    r := bufio.NewReaderSize(fp, 4*1024)
    line, isPrefix, err := r.ReadLine()
    for err == nil && !isPrefix {
        s := string(line)
        GetStatus(s, status, &totalSpace , &totalAvailable, &broken_datasets)
        line, isPrefix, err = r.ReadLine()
    }
    fmt.Printf("Total Space: %.1f GB | TotalAvailable: %.1f GB" , totalSpace, totalAvailable)
    fmt.Println("")

    if isPrefix {
        fmt.Println("buffer size to small")
        return
    }
    if err != io.EOF {
        fmt.Println(err)
        return
    }
    if len(broken_datasets) > 0 {
        fmt.Println(" ")
        fmt.Println("Failed to get space usage for the following FS: ")
        fmt.Println("------------------------------------------------ ")
        for _, i := range broken_datasets {
            fmt.Println(i)
        }
    }
}

func GetStatus(line, status string, totalSpace, totalAvailable *float64, broken_datasets *[]string) {
    if len(line) < 1 {
        // this is an empty line
        return
    }

    var filesystem string
    var state string

    if ( string(line[0]) == "/" ) {
        state  = "ACTIVE"
        filesystem = string(line[0:])
    } else {
        state = "INACTIVE"
        filesystem = string(line[1:])
        filesystem := strings.TrimSpace(filesystem)
        // if filesystem starts with / this is a valid path
        if !strings.HasPrefix(filesystem, "/") {
            return
        }
    }

    if status == "active" {
        if state == "INACTIVE" {
            return
        }
    }
    if status == "inactive" {
        if state == "ACTIVE" {
            return
        }
    }
    filesystem = strings.TrimSpace(filesystem)
    var stat syscall.Statfs_t
    syscall.Statfs(filesystem, &stat)
    var mavail string
    var mfull string
    mfull =" GB"
    mavail = " GB"
    gbsizeAvailable := float64(stat.Bavail * uint64(stat.Bsize))/1024/1024/1024
    *totalAvailable += gbsizeAvailable
    gbsizeAvailableStr := strconv.FormatFloat(gbsizeAvailable, 'f', 1, 64)
    if len(gbsizeAvailableStr) > 5 {
        gbsizeAvailable = gbsizeAvailable/1024
        mavail = " TB"
    }

    gbsizeTotal := float64(stat.Bsize * int64(stat.Blocks))/1024/1024/1024
    *totalSpace += gbsizeTotal
    gbsizeTotalStr := strconv.FormatFloat(gbsizeTotal, 'f', 1, 64)
    if len(gbsizeTotalStr) > 5 {
        gbsizeTotal = gbsizeTotal/1024
        mfull = " TB"
    }

    _, error := os.Stat(filesystem)
    if error != nil {
        errorstr := error.Error()
        *broken_datasets = append(*broken_datasets, "FS:  "+filesystem+" ==>> With ERROR: "+errorstr)
        return
    }

    fmt.Printf("FS: %-36s | STATE: %-16s | AVAIL: %.1f %-16s | TOTAL: %.1f %-16s" , filesystem, state, gbsizeAvailable, mavail, gbsizeTotal, mfull)
    fmt.Println("")

}

func main() {
    arsfilePtr := flag.String("arsfile", "/opt/ondemand/config/ars.cache", "Path to arsfile.")
    statePtr := flag.String("status", "all", "Print only active, inactive OR all filesystems from arsfile.")
    flag.Parse()
    arsfile := *arsfilePtr
    status := *statePtr
    if ( status != "active" && status != "inactive"  && status != "all") {
        fmt.Println("-status should be 'active' 'inactive' or 'all'")
        os.Exit(10)
     }
    RunProgram(arsfile, status)
